# Copyright 2018, Erlang Solutions Ltd.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import logging

from typing import Set, Union

from Pyrlang.Engine.base_engine import BaseEngine
from Pyrlang.bases import BaseNode, BaseProcess
from Term.pid import Pid

LOG = logging.getLogger("Pyrlang")


class Process(BaseProcess):
    """ Implements Erlang process semantic and lifetime.
        Registers itself in the process registry, can receive and send messages.
        To optionally register self with a name, call
        ``node.register_name(self, term.Atom('fgsfds'))``

        Subclass the Process to run your logic in its ``_loop() -> bool``
        function or to handle incoming messages via
        ``handle_one_inbox_message(self, msg)``.

        .. note::
            Only a ``Process`` can serve as a target for sending messages, for
            linking and monitoring. You do not need to create a Process for simple
            one-way interactions with remote Erlang nodes.
    """

    def __init__(self, node: Union[str, BaseNode], passive: bool = True) -> None:
        """ Create a process and register itself. Pid is generated by the node
            object. """
        self.passive_ = passive  # type: bool
        """ Having ``passive=True`` will only wake up this
            ``Process`` when a message arrives, to handle it, otherwise it will
            not get any CPU time for any empty polling loops. Having
            ``passive=False`` will run
            :py:func:`~Pyrlang.process.Process.process_loop``
            polling inbox.
        """

        from Pyrlang import Node
        node = node if isinstance(node, BaseNode) else Node.all_nodes[node]
        self.engine_ = node.engine_  # type: BaseEngine
        """ Pluggable async event engine """

        self.node_name_ = node.node_name_  # type: str
        """ Convenience field to see the Node (from Node.all_nodes[name]). """

        self.inbox_ = node.engine_.queue_new()
        """ Message queue (gevent.Queue). Messages are detected by the ``_run``
            loop and handled one by one in ``handle_one_inbox_message()``. 
        """

        self.pid_ = node.register_new_process(self)
        """ Process identifier for this object. Remember that when creating a 
            process, it registers itself in the node, and this creates a
            reference. 
            References prevent an object from being garbage collected.
            To destroy a process, get rid of this extra reference by calling
            ``exit()`` and telling it the cause of its death.
        """

        self.is_exiting_ = False

        self.monitors_ = set()  # type: Set[Pid]
        """ Who monitors us. Either local or remote processes. """

        self.monitor_targets_ = set()  # type: Set[Pid]
        """ Who we monitor. """

        LOG.debug("Spawned process %s", self.pid_)
        if not self.passive_:
            self.engine_.spawn(self.process_loop)

    def process_loop(self) -> bool:
        """ Polls inbox in an endless loop. Returns ``True`` to continue running.
            Return ``False`` to stop.

            .. note::
                This will not be executed if the process was constructed with
                ``passive=True`` (the default).
        """
        self.handle_inbox()
        if self.is_exiting_:
            LOG.debug("Process %s process_loop stopped", self.pid_)
            return False
        return True

    def handle_inbox(self):
        """ Do not override `handle_inbox`, instead go for
            `handle_one_inbox_message`
        """
        while True:
            msg = self.inbox_.get()
            if msg is None:
                break
            self.handle_one_inbox_message(msg)

    def handle_one_inbox_message(self, msg):
        """ Override this method to handle new incoming messages. """
        LOG.error("%s: Unhandled msg %s" % (self.pid_, msg))
        pass

    def deliver_message(self, msg):
        """ Places message into the inbox, or delivers it immediately to a
            handler (if process is ``passive``). """
        if self.passive_:
            self.handle_one_inbox_message(msg)
        else:
            self.inbox_.put(msg)

    def exit(self, reason=None):
        """ Marks the object as exiting with the reason, informs links and
            monitors and unregisters the object from the node process
            dictionary.
        """
        # TODO: Inform links and monitors

        from Pyrlang import Node
        n = Node.all_nodes[self.node_name_]
        n.on_exit_process(self.pid_, reason)
