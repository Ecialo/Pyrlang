# Copyright 2018, Erlang Solutions Ltd.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import asyncio
from typing import Set
import logging

# from pyrlang.node import Node
from pyrlang.term.pid import Pid

WARN = logging.warning
DEBUG = logging.debug


class Process:
    """ Implements Erlang process semantic and lifetime.
        Registers itself in the process registry, can receive and send messages.
        To optionally register self with a name, call
        ``node.register_name(self, term.Atom('fgsfds'))``
    """

    def __init__(self, node) -> None:
        """ Create a process and register itself. Pid is generated by the node
            object.

            :param node: 
        """
        self.node_ = node
        """ Convenience field to see the Node. """

        self.inbox_ = asyncio.Queue()
        """ Message queue (gevent.Queue). Messages are detected by the ``_run``
            loop and handled one by one in ``handle_one_inbox_message()``. 
        """

        self.pid_ = node.register_new_process(self)
        """ Process identifier for this object. Remember that when creating a 
            process, it registers itself in the node, and this creates a
            reference. 
            References prevent an object from being garbage collected.
            To destroy a process, get rid of this extra reference by calling
            ``exit()`` and telling it the cause of its death.
        """

        self.is_exiting_ = False

        self.monitors_ = set()  # type: Set[Pid]
        """ Who monitors us. Either local or remote processes. """

        self.monitor_targets_ = set()  # type: Set[Pid]
        """ Who we monitor. """

        # greenlet has to be scheduled for run
        asyncio.get_event_loop().create_task(self._run())

    async def _run(self):
        while not self.is_exiting_:
            await self._handle_inbox()  # ops with message queue will sleep

    async def _handle_inbox(self):
        """ Override `handle_one_inbox_message` when you want to process
            incoming messages
        """
        while True:
            # Block, but then gevent will allow other green-threads to
            # run, so rather than unnecessarily consuming CPU block
            msg = await self.inbox_.get()
            DEBUG("%s: handle_inbox %s" % (self, msg))
            if msg is None:
                break
            self.handle_one_inbox_message(msg)

    def handle_one_inbox_message(self, msg):
        """ Override this method to handle new incoming messages. """
        WARN("%s: Incoming msg %s" % (self.pid_, msg))

    def exit(self, reason=None):
        """ Marks the object as exiting with the reason, informs links and
            monitors and unregisters the object from the node process
            dictionary.
        """
        # TODO: Inform links and monitors

        self.node_.on_exit_process(self.pid_, reason)


__all__ = ["Process"]
